#include "framework_exporters.h"
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <cmath>

// QASM Exporter
std::string QASMExporter::exportCircuit(const QPUCircuit& circuit, const std::string& /* circuit_name */) {
    std::ostringstream oss;
    oss << "OPENQASM 2.0;\n";
    oss << "include \"qelib1.inc\";\n";
    oss << "qreg q[" << circuit.num_qubits << "];\n";
    oss << "creg c[" << circuit.num_qubits << "];\n\n";
    
    for (const auto& gate : circuit.gates) {
        switch (gate.type) {
            case GateType::H:
                oss << "h q[" << gate.target_qubit << "];\n";
                break;
            case GateType::X:
                oss << "x q[" << gate.target_qubit << "];\n";
                break;
            case GateType::Y:
                oss << "y q[" << gate.target_qubit << "];\n";
                break;
            case GateType::Z:
                oss << "z q[" << gate.target_qubit << "];\n";
                break;
            case GateType::CNOT:
                oss << "cx q[" << gate.control_qubit << "],q[" << gate.target_qubit << "];\n";
                break;
            case GateType::RZ:
                oss << "rz(" << gate.parameter << ") q[" << gate.target_qubit << "];\n";
                break;
            case GateType::RY:
                oss << "ry(" << gate.parameter << ") q[" << gate.target_qubit << "];\n";
                break;
            case GateType::RX:
                oss << "rx(" << gate.parameter << ") q[" << gate.target_qubit << "];\n";
                break;
            case GateType::CPHASE:
                oss << "cp(" << gate.parameter << ") q[" << gate.control_qubit 
                    << "],q[" << gate.target_qubit << "];\n";
                break;
            case GateType::MEASURE:
                oss << "measure q[" << gate.target_qubit << "] -> c[" << gate.target_qubit << "];\n";
                break;
        }
    }
    return oss.str();
}

// Qiskit Exporter
std::string QiskitExporter::exportCircuit(const QPUCircuit& circuit, const std::string& circuit_name) {
    std::ostringstream oss;
    oss << "#!/usr/bin/env python3\n";
    oss << "# Generated by MRF Compiler\n";
    oss << "# Copyright (C) 2025, Shyamal Suhana Chandra\n\n";
    oss << "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n";
    oss << "from qiskit.circuit.library import RYGate, RZGate, RXGate\n";
    oss << "import numpy as np\n\n";
    oss << "def create_" << circuit_name << "():\n";
    oss << "    \"\"\"\n";
    oss << "    Create a quantum circuit from MRF model.\n";
    oss << "    Returns: QuantumCircuit object\n";
    oss << "    \"\"\"\n";
    oss << "    qr = QuantumRegister(" << circuit.num_qubits << ", 'q')\n";
    oss << "    cr = ClassicalRegister(" << circuit.num_qubits << ", 'c')\n";
    oss << "    qc = QuantumCircuit(qr, cr)\n\n";
    
    for (const auto& gate : circuit.gates) {
        switch (gate.type) {
            case GateType::H:
                oss << "    qc.h(" << gate.target_qubit << ")\n";
                break;
            case GateType::X:
                oss << "    qc.x(" << gate.target_qubit << ")\n";
                break;
            case GateType::Y:
                oss << "    qc.y(" << gate.target_qubit << ")\n";
                break;
            case GateType::Z:
                oss << "    qc.z(" << gate.target_qubit << ")\n";
                break;
            case GateType::CNOT:
                oss << "    qc.cx(" << gate.control_qubit << ", " << gate.target_qubit << ")\n";
                break;
            case GateType::RZ:
                oss << "    qc.rz(" << gate.parameter << ", " << gate.target_qubit << ")\n";
                break;
            case GateType::RY:
                oss << "    qc.ry(" << gate.parameter << ", " << gate.target_qubit << ")\n";
                break;
            case GateType::RX:
                oss << "    qc.rx(" << gate.parameter << ", " << gate.target_qubit << ")\n";
                break;
            case GateType::CPHASE:
                oss << "    qc.cp(" << gate.parameter << ", " << gate.control_qubit 
                    << ", " << gate.target_qubit << ")\n";
                break;
            case GateType::MEASURE:
                oss << "    qc.measure(" << gate.target_qubit << ", " << gate.target_qubit << ")\n";
                break;
        }
    }
    
    oss << "\n    return qc\n\n";
    oss << "if __name__ == '__main__':\n";
    oss << "    qc = create_" << circuit_name << "()\n";
    oss << "    print(qc)\n";
    oss << "    print('\\nCircuit depth:', qc.depth())\n";
    oss << "    print('Total gates:', qc.size())\n";
    return oss.str();
}

// Cirq Exporter
std::string CirqExporter::exportCircuit(const QPUCircuit& circuit, const std::string& circuit_name) {
    std::ostringstream oss;
    oss << "#!/usr/bin/env python3\n";
    oss << "# Generated by MRF Compiler\n";
    oss << "# Copyright (C) 2025, Shyamal Suhana Chandra\n\n";
    oss << "import cirq\n";
    oss << "import numpy as np\n\n";
    oss << "def create_" << circuit_name << "():\n";
    oss << "    \"\"\"\n";
    oss << "    Create a quantum circuit from MRF model.\n";
    oss << "    Returns: cirq.Circuit object\n";
    oss << "    \"\"\"\n";
    oss << "    qubits = [cirq.LineQubit(i) for i in range(" << circuit.num_qubits << ")]\n";
    oss << "    circuit = cirq.Circuit()\n\n";
    
    for (const auto& gate : circuit.gates) {
        switch (gate.type) {
            case GateType::H:
                oss << "    circuit.append(cirq.H(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::X:
                oss << "    circuit.append(cirq.X(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::Y:
                oss << "    circuit.append(cirq.Y(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::Z:
                oss << "    circuit.append(cirq.Z(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::CNOT:
                oss << "    circuit.append(cirq.CNOT(qubits[" << gate.control_qubit 
                    << "], qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::RZ:
                oss << "    circuit.append(cirq.rz(" << gate.parameter 
                    << ")(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::RY:
                oss << "    circuit.append(cirq.ry(" << gate.parameter 
                    << ")(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::RX:
                oss << "    circuit.append(cirq.rx(" << gate.parameter 
                    << ")(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::CPHASE:
                oss << "    circuit.append(cirq.CZPowGate(exponent=" << gate.parameter 
                    << ")(qubits[" << gate.control_qubit << "], qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::MEASURE:
                oss << "    circuit.append(cirq.measure(qubits[" << gate.target_qubit 
                    << "], key='q" << gate.target_qubit << "'))\n";
                break;
        }
    }
    
    oss << "\n    return circuit\n\n";
    oss << "if __name__ == '__main__':\n";
    oss << "    circuit = create_" << circuit_name << "()\n";
    oss << "    print(circuit)\n";
    return oss.str();
}

// PennyLane Exporter
std::string PennyLaneExporter::exportCircuit(const QPUCircuit& circuit, const std::string& circuit_name) {
    std::ostringstream oss;
    oss << "#!/usr/bin/env python3\n";
    oss << "# Generated by MRF Compiler\n";
    oss << "# Copyright (C) 2025, Shyamal Suhana Chandra\n\n";
    oss << "import pennylane as qml\n";
    oss << "import numpy as np\n\n";
    oss << "dev = qml.device('default.qubit', wires=" << circuit.num_qubits << ", shots=1000)\n\n";
    oss << "@qml.qnode(dev)\n";
    oss << "def " << circuit_name << "():\n";
    oss << "    \"\"\"\n";
    oss << "    Quantum circuit from MRF model.\n";
    oss << "    Returns: measurement results\n";
    oss << "    \"\"\"\n";
    
    // Collect measurement qubits
    std::vector<int> measure_qubits;
    
    for (const auto& gate : circuit.gates) {
        switch (gate.type) {
            case GateType::H:
                oss << "    qml.Hadamard(wires=" << gate.target_qubit << ")\n";
                break;
            case GateType::X:
                oss << "    qml.PauliX(wires=" << gate.target_qubit << ")\n";
                break;
            case GateType::Y:
                oss << "    qml.PauliY(wires=" << gate.target_qubit << ")\n";
                break;
            case GateType::Z:
                oss << "    qml.PauliZ(wires=" << gate.target_qubit << ")\n";
                break;
            case GateType::CNOT:
                oss << "    qml.CNOT(wires=[" << gate.control_qubit << ", " << gate.target_qubit << "])\n";
                break;
            case GateType::RZ:
                oss << "    qml.RZ(" << gate.parameter << ", wires=" << gate.target_qubit << ")\n";
                break;
            case GateType::RY:
                oss << "    qml.RY(" << gate.parameter << ", wires=" << gate.target_qubit << ")\n";
                break;
            case GateType::RX:
                oss << "    qml.RX(" << gate.parameter << ", wires=" << gate.target_qubit << ")\n";
                break;
            case GateType::CPHASE:
                oss << "    qml.CPhase(" << gate.parameter << ", wires=[" << gate.control_qubit 
                    << ", " << gate.target_qubit << "])\n";
                break;
            case GateType::MEASURE:
                measure_qubits.push_back(gate.target_qubit);
                break;
        }
    }
    
    // Add measurement at the end
    if (!measure_qubits.empty()) {
        if (measure_qubits.size() == 1) {
            oss << "    return qml.sample(qml.PauliZ(wires=" << measure_qubits[0] << "))\n";
        } else {
            oss << "    return qml.sample([";
            for (size_t i = 0; i < measure_qubits.size(); i++) {
                oss << "qml.PauliZ(wires=" << measure_qubits[i] << ")";
                if (i < measure_qubits.size() - 1) oss << ", ";
            }
            oss << "])\n";
        }
    } else {
        // Default: measure all qubits
        oss << "    return qml.sample([";
        for (int i = 0; i < circuit.num_qubits; i++) {
            oss << "qml.PauliZ(wires=" << i << ")";
            if (i < circuit.num_qubits - 1) oss << ", ";
        }
        oss << "])\n";
    }
    
    oss << "\nif __name__ == '__main__':\n";
    oss << "    result = " << circuit_name << "()\n";
    oss << "    print('Measurement result:', result)\n";
    oss << "    print('\\nCircuit:')\n";
    oss << "    print(" << circuit_name << ".qtape)\n";
    return oss.str();
}

// Q# Exporter
std::string QSharpExporter::exportCircuit(const QPUCircuit& circuit, const std::string& circuit_name) {
    std::ostringstream oss;
    oss << "// Generated by MRF Compiler\n";
    oss << "// Copyright (C) 2025, Shyamal Suhana Chandra\n\n";
    oss << "namespace " << circuit_name << " {\n";
    oss << "    open Microsoft.Quantum.Intrinsic;\n";
    oss << "    open Microsoft.Quantum.Math;\n\n";
    oss << "    operation " << circuit_name << "(qs : Qubit[]) : Unit {\n";
    
    for (const auto& gate : circuit.gates) {
        switch (gate.type) {
            case GateType::H:
                oss << "        H(qs[" << gate.target_qubit << "]);\n";
                break;
            case GateType::X:
                oss << "        X(qs[" << gate.target_qubit << "]);\n";
                break;
            case GateType::Y:
                oss << "        Y(qs[" << gate.target_qubit << "]);\n";
                break;
            case GateType::Z:
                oss << "        Z(qs[" << gate.target_qubit << "]);\n";
                break;
            case GateType::CNOT:
                oss << "        CNOT(qs[" << gate.control_qubit << "], qs[" << gate.target_qubit << "]);\n";
                break;
            case GateType::RZ:
                oss << "        Rz(" << gate.parameter << ", qs[" << gate.target_qubit << "]);\n";
                break;
            case GateType::RY:
                oss << "        Ry(" << gate.parameter << ", qs[" << gate.target_qubit << "]);\n";
                break;
            case GateType::RX:
                oss << "        Rx(" << gate.parameter << ", qs[" << gate.target_qubit << "]);\n";
                break;
            case GateType::CPHASE:
                oss << "        R1(" << gate.parameter << ", qs[" << gate.target_qubit << "]);\n";
                oss << "        Controlled Z([qs[" << gate.control_qubit << "]], qs[" << gate.target_qubit << "]);\n";
                break;
            case GateType::MEASURE:
                // Q# measurements are typically done in calling code
                break;
        }
    }
    
    oss << "    }\n";
    oss << "}\n";
    return oss.str();
}

// AWS Braket Exporter
std::string BraketExporter::exportCircuit(const QPUCircuit& circuit, const std::string& circuit_name) {
    std::ostringstream oss;
    oss << "#!/usr/bin/env python3\n";
    oss << "# Generated by MRF Compiler\n";
    oss << "# Copyright (C) 2025, Shyamal Suhana Chandra\n\n";
    oss << "from braket.circuits import Circuit\n";
    oss << "from braket.circuits import gates\n";
    oss << "import numpy as np\n\n";
    oss << "def create_" << circuit_name << "():\n";
    oss << "    \"\"\"\n";
    oss << "    Create a quantum circuit from MRF model.\n";
    oss << "    Returns: braket.Circuit object\n";
    oss << "    \"\"\"\n";
    oss << "    circuit = Circuit()\n\n";
    
    for (const auto& gate : circuit.gates) {
        switch (gate.type) {
            case GateType::H:
                oss << "    circuit.h(" << gate.target_qubit << ")\n";
                break;
            case GateType::X:
                oss << "    circuit.x(" << gate.target_qubit << ")\n";
                break;
            case GateType::Y:
                oss << "    circuit.y(" << gate.target_qubit << ")\n";
                break;
            case GateType::Z:
                oss << "    circuit.z(" << gate.target_qubit << ")\n";
                break;
            case GateType::CNOT:
                oss << "    circuit.cnot(" << gate.control_qubit << ", " << gate.target_qubit << ")\n";
                break;
            case GateType::RZ:
                oss << "    circuit.rz(" << gate.target_qubit << ", " << gate.parameter << ")\n";
                break;
            case GateType::RY:
                oss << "    circuit.ry(" << gate.target_qubit << ", " << gate.parameter << ")\n";
                break;
            case GateType::RX:
                oss << "    circuit.rx(" << gate.target_qubit << ", " << gate.parameter << ")\n";
                break;
            case GateType::CPHASE:
                oss << "    circuit.cphaseshift(" << gate.control_qubit << ", " << gate.target_qubit 
                    << ", " << gate.parameter << ")\n";
                break;
            case GateType::MEASURE:
                oss << "    circuit.probability(target=[" << gate.target_qubit << "])\n";
                break;
        }
    }
    
    oss << "\n    return circuit\n\n";
    oss << "if __name__ == '__main__':\n";
    oss << "    circuit = create_" << circuit_name << "()\n";
    oss << "    print(circuit)\n";
    return oss.str();
}

// Qulacs Exporter
std::string QulacsExporter::exportCircuit(const QPUCircuit& circuit, const std::string& circuit_name) {
    std::ostringstream oss;
    oss << "#!/usr/bin/env python3\n";
    oss << "# Generated by MRF Compiler\n";
    oss << "# Copyright (C) 2025, Shyamal Suhana Chandra\n\n";
    oss << "from qulacs import QuantumState, QuantumCircuit\n";
    oss << "import numpy as np\n\n";
    oss << "def create_" << circuit_name << "():\n";
    oss << "    \"\"\"\n";
    oss << "    Create a quantum circuit from MRF model.\n";
    oss << "    Returns: qulacs.QuantumCircuit object\n";
    oss << "    \"\"\"\n";
    oss << "    n_qubits = " << circuit.num_qubits << "\n";
    oss << "    circuit = QuantumCircuit(n_qubits)\n\n";
    
    for (const auto& gate : circuit.gates) {
        switch (gate.type) {
            case GateType::H:
                oss << "    circuit.add_H_gate(" << gate.target_qubit << ")\n";
                break;
            case GateType::X:
                oss << "    circuit.add_X_gate(" << gate.target_qubit << ")\n";
                break;
            case GateType::Y:
                oss << "    circuit.add_Y_gate(" << gate.target_qubit << ")\n";
                break;
            case GateType::Z:
                oss << "    circuit.add_Z_gate(" << gate.target_qubit << ")\n";
                break;
            case GateType::CNOT:
                oss << "    circuit.add_CNOT_gate(" << gate.control_qubit << ", " << gate.target_qubit << ")\n";
                break;
            case GateType::RZ:
                oss << "    circuit.add_parametric_RZ_gate(" << gate.target_qubit << ", " << gate.parameter << ")\n";
                break;
            case GateType::RY:
                oss << "    circuit.add_parametric_RY_gate(" << gate.target_qubit << ", " << gate.parameter << ")\n";
                break;
            case GateType::RX:
                oss << "    circuit.add_parametric_RX_gate(" << gate.target_qubit << ", " << gate.parameter << ")\n";
                break;
            case GateType::CPHASE:
                oss << "    circuit.add_parametric_multi_Pauli_rotation_gate(["
                    << gate.control_qubit << ", " << gate.target_qubit 
                    << "], [3, 3], " << gate.parameter << ")\n";
                break;
            case GateType::MEASURE:
                // Qulacs measurements are done separately
                break;
        }
    }
    
    oss << "\n    return circuit\n\n";
    oss << "if __name__ == '__main__':\n";
    oss << "    circuit = create_" << circuit_name << "()\n";
    oss << "    state = QuantumState(" << circuit.num_qubits << ")\n";
    oss << "    circuit.update_quantum_state(state)\n";
    oss << "    print('Circuit created with', " << circuit.num_qubits << ", qubits')\n";
    return oss.str();
}

// TensorFlow Quantum Exporter
std::string TFQExporter::exportCircuit(const QPUCircuit& circuit, const std::string& circuit_name) {
    std::ostringstream oss;
    oss << "#!/usr/bin/env python3\n";
    oss << "# Generated by MRF Compiler\n";
    oss << "# Copyright (C) 2025, Shyamal Suhana Chandra\n\n";
    oss << "import tensorflow_quantum as tfq\n";
    oss << "import cirq\n";
    oss << "import numpy as np\n\n";
    oss << "def create_" << circuit_name << "():\n";
    oss << "    \"\"\"\n";
    oss << "    Create a quantum circuit from MRF model.\n";
    oss << "    Returns: tfq.PaddedCircuit object\n";
    oss << "    \"\"\"\n";
    oss << "    qubits = [cirq.LineQubit(i) for i in range(" << circuit.num_qubits << ")]\n";
    oss << "    circuit = cirq.Circuit()\n\n";
    
    for (const auto& gate : circuit.gates) {
        switch (gate.type) {
            case GateType::H:
                oss << "    circuit.append(cirq.H(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::X:
                oss << "    circuit.append(cirq.X(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::Y:
                oss << "    circuit.append(cirq.Y(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::Z:
                oss << "    circuit.append(cirq.Z(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::CNOT:
                oss << "    circuit.append(cirq.CNOT(qubits[" << gate.control_qubit 
                    << "], qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::RZ:
                oss << "    circuit.append(cirq.rz(" << gate.parameter 
                    << ")(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::RY:
                oss << "    circuit.append(cirq.ry(" << gate.parameter 
                    << ")(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::RX:
                oss << "    circuit.append(cirq.rx(" << gate.parameter 
                    << ")(qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::CPHASE:
                oss << "    circuit.append(cirq.CZPowGate(exponent=" << gate.parameter 
                    << ")(qubits[" << gate.control_qubit << "], qubits[" << gate.target_qubit << "]))\n";
                break;
            case GateType::MEASURE:
                oss << "    circuit.append(cirq.measure(qubits[" << gate.target_qubit 
                    << "], key='q" << gate.target_qubit << "'))\n";
                break;
        }
    }
    
    oss << "\n    return tfq.convert_to_tensor([circuit])\n\n";
    oss << "if __name__ == '__main__':\n";
    oss << "    circuit_tensor = create_" << circuit_name << "()\n";
    oss << "    print('Circuit tensor shape:', circuit_tensor.shape)\n";
    return oss.str();
}

// Factory function
FrameworkExporter* createExporter(Framework framework) {
    switch (framework) {
        case Framework::QASM:
            return new QASMExporter();
        case Framework::QISKIT:
            return new QiskitExporter();
        case Framework::CIRQ:
            return new CirqExporter();
        case Framework::PENNYLANE:
            return new PennyLaneExporter();
        case Framework::QSHARP:
            return new QSharpExporter();
        case Framework::BRAKET:
            return new BraketExporter();
        case Framework::QULACS:
            return new QulacsExporter();
        case Framework::TENSORFLOW_QUANTUM:
            return new TFQExporter();
        default:
            return new QASMExporter();
    }
}

std::string frameworkToString(Framework framework) {
    switch (framework) {
        case Framework::QASM: return "qasm";
        case Framework::QISKIT: return "qiskit";
        case Framework::CIRQ: return "cirq";
        case Framework::PENNYLANE: return "pennylane";
        case Framework::QSHARP: return "qsharp";
        case Framework::BRAKET: return "braket";
        case Framework::QULACS: return "qulacs";
        case Framework::TENSORFLOW_QUANTUM: return "tfq";
        default: return "qasm";
    }
}

Framework stringToFramework(const std::string& str) {
    std::string lower = str;
    std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
    
    if (lower == "qiskit") return Framework::QISKIT;
    if (lower == "cirq") return Framework::CIRQ;
    if (lower == "pennylane") return Framework::PENNYLANE;
    if (lower == "qsharp" || lower == "q#") return Framework::QSHARP;
    if (lower == "braket") return Framework::BRAKET;
    if (lower == "qulacs") return Framework::QULACS;
    if (lower == "tfq" || lower == "tensorflow_quantum") return Framework::TENSORFLOW_QUANTUM;
    return Framework::QASM;  // Default
}
